"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseV1Relationships = exports.getInverseRelationship = exports.isInverseRelationshipDefined = void 0;
const parse_1 = require("./parse");
const InverseType = {
    OneToOne: "OneToOne",
    OneToMany: "ManyToOne",
    ManyToOne: "OneToMany",
    ManyToMany: "ManyToMany",
};
const isInverseRelationshipDefined = (entityName, association, entities) => {
    if (entityName === association.name) {
        return false;
    }
    return Boolean((0, exports.getInverseRelationship)(entityName, association, entities));
};
exports.isInverseRelationshipDefined = isInverseRelationshipDefined;
const getInverseRelationship = (entityName, association, entities) => {
    var _a, _b;
    if (entityName === association.name) {
        return null;
    }
    const inverseAssociationType = InverseType[association.type];
    const isInverse = (testAssocation) => testAssocation.name === entityName &&
        testAssocation.type === inverseAssociationType;
    return (((_b = (_a = entities
        .find((entity) => entity.name === association.name)) === null || _a === void 0 ? void 0 : _a.associations) === null || _b === void 0 ? void 0 : _b.find(isInverse)) || null);
};
exports.getInverseRelationship = getInverseRelationship;
const convertAssociationToRelationship = (entityName, association, entities) => {
    const inverseRelation = (0, exports.getInverseRelationship)(entityName, association, entities);
    let biDirectional = Boolean(inverseRelation);
    let index = association.index;
    if (association.type === "OneToMany" && inverseRelation) {
        index = inverseRelation.index || false;
    }
    if (association.type === "ManyToOne" && biDirectional) {
        return null;
    }
    if (association.type === "ManyToMany" && inverseRelation) {
        if (association.join_table !== true &&
            inverseRelation.join_table === true) {
            return null;
        }
        if (association.join_table === true &&
            inverseRelation.join_table === true) {
            // Both ManyToMany sides have join_table set to true
            biDirectional = false;
        }
    }
    const inverseNullable = (inverseRelation && inverseRelation.nullable) || false;
    return {
        from: entityName,
        to: association.name,
        type: association.type,
        /* eslint-disable-next-line  camelcase */
        to_name: association.reference_name,
        nullable: association.nullable || inverseNullable,
        /* eslint-disable-next-line  camelcase */
        bi_directional: biDirectional,
        index,
    };
};
const parseV1Relationships = (entities) => {
    const relationshipMap = {};
    for (const entity of entities) {
        if (!entity.associations) {
            continue;
        }
        for (const association of entity.associations) {
            const apsorcRelationship = convertAssociationToRelationship(entity.name, association, entities);
            if (apsorcRelationship === null) {
                continue;
            }
            const parsedResult = (0, parse_1.parseRelationship)(apsorcRelationship);
            for (const key of Object.keys(parsedResult)) {
                relationshipMap[key] = [
                    ...(relationshipMap[key] || []),
                    ...parsedResult[key],
                ];
            }
        }
    }
    return relationshipMap;
};
exports.parseV1Relationships = parseV1Relationships;
