"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelationshipsForImport = exports.getNestedRelationships = exports.getRelationshipForTemplate = exports.getRelationshipIdField = exports.parseRelationships = exports.parseRelationship = exports.parseOneToOne = exports.parseManyToMany = exports.parseManytoOne = exports.parseOneToMany = void 0;
const tslib_1 = require("tslib");
const pluralize_1 = tslib_1.__importDefault(require("pluralize"));
const casing_1 = require("../../utils/casing");
const parseOneToMany = (relationship) => {
    return {
        [relationship.from]: [
            {
                name: relationship.to,
                type: "OneToMany",
                biDirectional: true
            },
        ],
        [relationship.to]: [
            {
                name: relationship.from,
                type: "ManyToOne",
                nullable: relationship.nullable || false,
                biDirectional: true,
                index: relationship.index || false,
                cascadeDelete: relationship.cascadeDelete || false
            },
        ],
    };
};
exports.parseOneToMany = parseOneToMany;
const parseManytoOne = (relationship) => {
    return {
        [relationship.from]: [
            {
                name: relationship.to,
                type: "ManyToOne",
                referenceName: relationship.to_name || null,
                nullable: relationship.nullable || false,
                index: relationship.index || false,
            },
        ],
    };
};
exports.parseManytoOne = parseManytoOne;
const parseManyToMany = (relationship) => {
    const response = {
        [relationship.from]: [
            {
                name: relationship.to,
                type: "ManyToMany",
                referenceName: relationship.to_name || null,
                join: true,
                biDirectional: relationship.bi_directional || false,
            },
        ],
    };
    if (relationship.bi_directional) {
        response[relationship.to] = [
            {
                name: relationship.from,
                type: "ManyToMany",
                biDirectional: true,
            },
        ];
    }
    return response;
};
exports.parseManyToMany = parseManyToMany;
const parseOneToOne = (relationship) => {
    const response = {
        [relationship.from]: [
            {
                name: relationship.to,
                type: "OneToOne",
                join: true,
                nullable: relationship.nullable || false,
                referenceName: relationship.to_name || null,
                biDirectional: relationship.bi_directional || false,
            },
        ],
    };
    if (relationship.bi_directional) {
        response[relationship.to] = [
            {
                name: relationship.from,
                type: "OneToOne",
                biDirectional: true,
            },
        ];
    }
    return response;
};
exports.parseOneToOne = parseOneToOne;
const parseRelationship = (relationship) => {
    switch (relationship.type) {
        case "OneToMany":
            return (0, exports.parseOneToMany)(relationship);
        case "ManyToOne":
            return (0, exports.parseManytoOne)(relationship);
        case "ManyToMany":
            return (0, exports.parseManyToMany)(relationship);
        case "OneToOne":
            return (0, exports.parseOneToOne)(relationship);
    }
    return {};
};
exports.parseRelationship = parseRelationship;
const parseRelationships = (relationships) => {
    const response = {};
    for (const rel of relationships) {
        const parsedResult = (0, exports.parseRelationship)(rel);
        for (const key of Object.keys(parsedResult)) {
            response[key] = [...(response[key] || []), ...parsedResult[key]];
        }
    }
    return response;
};
exports.parseRelationships = parseRelationships;
const getRelationshipName = (relationship) => {
    if (relationship.referenceName) {
        return (0, casing_1.camelCase)(relationship.referenceName);
    }
    return (0, casing_1.camelCase)(relationship.name);
};
const getRelationshipIdField = (relationship) => {
    return `${getRelationshipName(relationship)}Id`;
};
exports.getRelationshipIdField = getRelationshipIdField;
const getRelationshipForTemplate = (entityName, relationships) => {
    if (!relationships) {
        return [];
    }
    return relationships.map((relationship) => {
        const relationshipName = getRelationshipName(relationship);
        return {
            ...relationship,
            relationshipName,
            pluralizedRelationshipName: (0, pluralize_1.default)(relationshipName),
            pluralizedName: (0, pluralize_1.default)((0, casing_1.camelCase)(relationship.name)),
            camelCasedName: (0, casing_1.camelCase)(relationship.name),
            camelCasedId: (0, exports.getRelationshipIdField)(relationship),
            entityName: (0, casing_1.camelCase)(entityName),
            joinTable: relationship.join || false,
            biDirectional: relationship.biDirectional || false,
            cascadeDelete: relationship.cascadeDelete || false,
        };
    });
};
exports.getRelationshipForTemplate = getRelationshipForTemplate;
const getNestedRelationships = (entityName, relationshipMap, prefix = "", visited = new Set()) => {
    const relationships = [];
    if (visited.has(entityName)) {
        return relationships;
    }
    const currentRelationships = relationshipMap[entityName];
    if (!currentRelationships)
        return relationships;
    visited.add(entityName);
    for (const relationship of currentRelationships) {
        const { name: relationshipName, type } = relationship;
        const referenceName = getRelationshipName(relationship);
        const formattedName = type === "ManyToOne" || type === "OneToOne"
            ? (0, casing_1.camelCase)(referenceName)
            : (0, pluralize_1.default)((0, casing_1.camelCase)(referenceName));
        const relationshipPath = prefix
            ? `${prefix}.${formattedName}`
            : formattedName;
        const hasChild = relationshipPath.includes(".");
        const exists = prefix
            .split(".")
            .some((a) => a === (0, casing_1.camelCase)(referenceName) ||
            a === (0, pluralize_1.default)((0, casing_1.camelCase)(referenceName)));
        const deepEnough = prefix.split(".").length >= 4;
        const canAdd = hasChild && !exists && !deepEnough;
        if (canAdd) {
            relationships.push(relationshipPath);
        }
        const nestedRelationships = (0, exports.getNestedRelationships)(relationshipName, relationshipMap, relationshipPath, new Set(visited));
        relationships.push(...nestedRelationships);
    }
    return relationships;
};
exports.getNestedRelationships = getNestedRelationships;
const getRelationshipsForImport = (entityName, relationships) => {
    if (relationships === undefined) {
        return [];
    }
    return [
        ...new Set(relationships
            .map((relationship) => relationship.name)
            .filter((relationshipName) => relationshipName !== entityName)),
    ];
};
exports.getRelationshipsForImport = getRelationshipsForImport;
